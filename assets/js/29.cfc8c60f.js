(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{430:function(a,t,s){"use strict";s.r(t);var r=s(2),v=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"三层类加载器架构和双亲委派模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三层类加载器架构和双亲委派模型"}},[a._v("#")]),a._v(" 三层类加载器架构和双亲委派模型")]),a._v(" "),t("img",{attrs:{src:"https://billrepo.oss-cn-hangzhou.aliyuncs.com/doc-img/image-20220923162326518.png"}}),a._v(" "),t("h2",{attrs:{id:"三层类加载器架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三层类加载器架构"}},[a._v("#")]),a._v(" 三层类加载器架构")]),a._v(" "),t("h3",{attrs:{id:"启动类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#启动类加载器"}},[a._v("#")]),a._v(" 启动类加载器")]),a._v(" "),t("p",[a._v("启动类加载器（Bootstrap Class Loader）：使用"),t("strong",[a._v("C++语言")]),a._v("实现，负责加载存放在<JAVA_HOME>\\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的类库加载到虚拟机的内存中。")]),a._v(" "),t("ul",[t("li",[a._v("启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用null代替即可")])]),a._v(" "),t("h3",{attrs:{id:"扩展类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#扩展类加载器"}},[a._v("#")]),a._v(" 扩展类加载器")]),a._v(" "),t("p",[a._v("扩展类加载器（Extension Class Loader）：这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以"),t("strong",[a._v("Java代码")]),a._v("的形式实现的。它负责加载<JAVA_HOME>\\lib\\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("根据“扩展类加载器”这个名称，就可以推断出这是一种Java系统类库的扩展机制，JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能。")])]),a._v(" "),t("li",[t("p",[a._v("在JDK9之后，这种扩展机制被模块化带来的天然的扩展能力所取代。由于扩展类加载器是由Java代码实现的，开发者可以直接在程序中使用扩展类加载器来加载Class文件。")])])]),a._v(" "),t("h3",{attrs:{id:"应用程序类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用程序类加载器"}},[a._v("#")]),a._v(" 应用程序类加载器")]),a._v(" "),t("p",[a._v("应用程序类加载器（Application Class Loader）：这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystemClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。")]),a._v(" "),t("ul",[t("li",[a._v("它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。")]),a._v(" "),t("li",[a._v("如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。")])]),a._v(" "),t("h2",{attrs:{id:"双亲委派模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派模型"}},[a._v("#")]),a._v(" 双亲委派模型")]),a._v(" "),t("p",[a._v("图7-2中展示的各种类加载器之间的层次关系被称为类加载器的“双亲委派模型（Parents Delegation Model）”。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。")]),a._v(" "),t("p",[a._v("双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先"),t("strong",[a._v("不会自己去尝试加载这个类")]),a._v("，而是"),t("strong",[a._v("把这个请求委派给父类加载器去完成")]),a._v("，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。")]),a._v(" "),t("h1",{attrs:{id:"用户自己写一个string类会发生什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用户自己写一个string类会发生什么"}},[a._v("#")]),a._v(" 用户自己写一个string类会发生什么？")]),a._v(" "),t("p",[a._v("假设用户自己写了一个String类，会发现该类加载不进内存。")]),a._v(" "),t("p",[a._v("原因：")]),a._v(" "),t("p",[a._v("基于JVM的双亲委派机制，类加载器收到了加载类的请求，会把这个请求委派给他的"),t("strong",[a._v("父类")]),a._v("加载器。")]),a._v(" "),t("p",[a._v("而只有父类加载器自己无法完成加载请求时，子类才会自己加载。\n这样用户自定义的String类的加载请求就会最终达到顶层的BootStrap ClassLoader启动类加载器，而启动类加载器能够加载String类，因为在java包下有，所以加载的是Java中的String，而不是自定义的，所以用户编写的java.lang.String不会被加载。")]),a._v(" "),t("p",[a._v('不能自己写以"java."开头的类，其要么由于类加载器的'),t("strong",[a._v("双亲委派机制")]),a._v("不能加载进内存；要么即使用自定义的类加载器去"),t("strong",[a._v("强行加载")]),a._v("，也会收到一个安全异常。")])])}),[],!1,null,null,null);t.default=v.exports}}]);
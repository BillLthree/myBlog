(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{423:function(a,r,e){"use strict";e.r(r);var t=e(2),o=Object(t.a)({},(function(){var a=this,r=a._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("img",{attrs:{src:a.$withBase("/R-C.png"),alt:"R-C",width:"600px",height:"300px",align:"center"}}),a._v(" "),r("h1",{attrs:{id:"kafka-科普"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#kafka-科普"}},[a._v("#")]),a._v(" Kafka 科普")]),a._v(" "),r("p",[a._v("摘要：本文主要介绍了 Kafka 的一些基本知识，包含 Topic、Partition、消费者、生产者等基本概念。")]),a._v(" "),r("h1",{attrs:{id:"一、什么是kafka"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一、什么是kafka"}},[a._v("#")]),a._v(" 一、什么是Kafka?")]),a._v(" "),r("p",[r("strong",[a._v("消息系统")])]),a._v(" "),r("p",[a._v("Kafka 和传统的消息系统(也称作消息中间件)都具备系统解耦、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复性等功能。与此同时，Kafka 还提供了大多数消息系统难以实现的消息顺序性保障及回溯消费的功能。")]),a._v(" "),r("p",[r("strong",[a._v("存储系统")])]),a._v(" "),r("p",[a._v("Kafka 把消息持久化到磁盘，相比于其他基于内存存储的系统而言，有效地降低了数据丢失的风险。也正是得益于 Kafka 的消息持久化功能和多副本机制，我们可以把 Kafka 作为长期的数据存储系统来使用，只需要把对应的数据保留策略设置 为“永久”或启用主题的日志压缩功能即可。参考：可行性分析："),r("a",{attrs:{href:"https://link.juejin.cn/?target=https%3A%2F%2Fwww.confluent.io%2Fblog%2Fokay-store-data-apache-kafka%2F",target:"_blank",rel:"noopener noreferrer"}},[a._v("www.confluent.io/blog/okay-s…"),r("OutboundLink")],1),a._v(" 和案例："),r("a",{attrs:{href:"https://link.juejin.cn/?target=https%3A%2F%2Fwww.confluent.io%2Fblog%2Fpublishing-apache-kafka-new-york-times%2F%E3%80%82",target:"_blank",rel:"noopener noreferrer"}},[a._v("www.confluent.io/blog/publis…"),r("OutboundLink")],1)]),a._v(" "),r("p",[r("strong",[a._v("流式处理平台")])]),a._v(" "),r("p",[a._v("Kafka 不仅为每个流行的流式处理框架提供了可靠的数据来源，还提供了一个完整的流式处理类库，比如窗口、连接、变换和聚合等各类操作。")]),a._v(" "),r("h1",{attrs:{id:"二、kafka基础概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二、kafka基础概念"}},[a._v("#")]),a._v(" 二、Kafka基础概念")]),a._v(" "),r("h2",{attrs:{id:"_1-kafka整体架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-kafka整体架构"}},[a._v("#")]),a._v(" 1.Kafka整体架构")]),a._v(" "),r("p",[a._v("一个典型的 Kafka 体系架构包括若干 Producer、若干 Broker、若干 Consumer，以及一个 ZooKeeper 集群，如图所示。其中 ZooKeeper 是 Kafka 用来负责集群元数据的管理、控制器 的选举等操作的。Producer 将消息发送到 Broker，Broker 负责将收到的消息存储到磁盘中，而 Consumer 负责从 Broker 订阅并消费消息。")]),a._v(" "),r("p",[a._v("整个 Kafka 体系结构中引入了以下 3 个术语。")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("Producer：生产者，也就是发送消息的一方。生产者负责创建消息，然后将其投递到 Kafka 中。")])]),a._v(" "),r("li",[r("p",[a._v("Consumer：消费者，也就是接收消息的一方。消费者连接到 Kafka 上并接收消息，进 而进行相应的业务逻辑处理。")])]),a._v(" "),r("li",[r("p",[a._v("Broker：服务代理节点。对于 Kafka 而言，Broker 可以简单地看作一个独立的 Kafka 服务节点或 Kafka 服务实例。大多数情况下也可以将 Broker 看作一台 Kafka 服务器，前提是这台服务器上只部署了一个 Kafka 实例。一个或多个 Broker 组成了一个 Kafka 集群。一般而言， 我们更习惯使用首字母小写的 broker 来表示服务代理节点。")])])]),a._v(" "),r("h2",{attrs:{id:"_2-kafka基础概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-kafka基础概念"}},[a._v("#")]),a._v(" 2.Kafka基础概念")]),a._v(" "),r("p",[a._v("在 Kafka 中还有两个特别重要的概念——主题（Topic）与分区（Partition）。Kafka 中的消息以 topic 题为单位进行归类，生产者负责将消息发送到特定的 topic (发送到 Kafka 集群中的每一条消息都要指定一个主题)，而消费者负责订阅主题并进行消费。")]),a._v(" "),r("p",[a._v("主题是一个逻辑上的概念，它还可以细分为多个分区，一个分区只属于单个主题，很多时候也会把分区称为主题分区（Topic-Partition）。同一主题下的不同分区包含的消息是不同的，分区在存储层面可以看作一个可追加的日志（Log）文件，消息在被追加到分区日志文件的时候都会分配一个特定的偏移量（offset）。offset 是消息在分区中的唯一标识，Kafka 通过它来保证消息在分区内的顺序性，不过 offset 并不跨越分区，也就是说，Kafka 保证的是分区有序而不是主题有序。")]),a._v(" "),r("p",[a._v("主题中有 多个 个分区，消息被顺序追加到每个分区日志文件的尾部。Kafka 中的分区可以分布在不同的服务器（broker）上，也就是说，一个主题可以横跨多个 broker，以此来提供比单个 broker 更强大的性能。")]),a._v(" "),r("p",[a._v("每一条消息被发送到 broker 之前，会根据分区规则选择被存储到哪个具体的分区。如果分区规则设定得合理，所有的消息都可以均匀地分配在不同的分区中。如果一个主题只对应一个文件，那么这个文件所在的机器 I/O 将会成为这个主题的性能瓶颈，而分区解决了这个问题。 在创建主题的时候可以通过指定的参数来设置分区的个数，当然也可以在主题创建完成之后去修改分区的数量，通过增加分区的数量可以实现水平扩展。")]),a._v(" "),r("h2",{attrs:{id:"_3-生产者与消费者"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-生产者与消费者"}},[a._v("#")]),a._v(" 3.生产者与消费者")]),a._v(" "),r("p",[a._v("对于 Kafka 来说客户端有两种基本类型：生产者（Producer）和消费者（Consumer）。除此之外，还有用来做数据集成的 Kafka Connect API 和流式处理的 Kafka Streams 等高阶客户端，但这些高阶客户端底层仍然是生产者和消费者API，它们只不过是在上层做了封装。")]),a._v(" "),r("p",[a._v("这很容易理解，生产者（也称为发布者）创建消息，而消费者（也称为订阅者）负责消费or读取消息。")]),a._v(" "),r("p",[a._v("在 Kafka 的消费理念中还有一层消费组（Consumer Group)）的概念，每个消费者都有一个对应的消费组。当消息发布到主题后，只会被投递给订阅它的每个消费组中的一个消费者。")]),a._v(" "),r("h2",{attrs:{id:"_4-broker-和集群-cluster"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-broker-和集群-cluster"}},[a._v("#")]),a._v(" 4.Broker 和集群（Cluster）")]),a._v(" "),r("p",[a._v("一个 Kafka 服务器也称为 Broker，它接受生产者发送的消息并存入磁盘；Broker 同时服务消费者拉取分区消息的请求，返回目前已经提交的消息。使用特定的机器硬件，一个 Broker 每秒可以处理成千上万的分区和百万量级的消息。（现在动不动就百万量级..我特地去查了一把，好像确实集群的情况下吞吐量挺高的..摁..）")]),a._v(" "),r("p",[a._v("若干个 Broker 组成一个集群（Cluster），其中集群内某个 Broker 会成为集群控制器（Cluster Controller），它负责管理集群，包括分配分区到 Broker、监控 Broker 故障等。在集群内，一个分区由一个 Broker 负责，这个 Broker 也称为这个分区的 Leader；当然一个分区可以被复制到多个 Broker 上来实现冗余，这样当存在 Broker 故障时可以将其分区重新分配到其他 Broker 来负责。")])])}),[],!1,null,null,null);r.default=o.exports}}]);
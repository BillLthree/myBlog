(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{417:function(t,s,_){"use strict";_.r(s);var e=_(2),v=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"io多路复用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#io多路复用"}},[t._v("#")]),t._v(" IO多路复用")]),t._v(" "),s("p",[t._v("IO 多路复用模型(即经典的Reactor设计模式)。")]),t._v(" "),s("p",[t._v("IO 多路复用是在高并发场景中使用最为广泛的一种 IO 模型，如 "),s("strong",[t._v("Java 的 NIO")]),t._v("、Redis、Nginx 的底层实现就是此类 IO 模型的应用，经典的"),s("strong",[t._v("Reactor 模式")]),t._v("也是基于此类 IO 模型。")]),t._v(" "),s("p",[t._v("I/O多路复用就是通过一种机制，一个进程或线程可以监视多个描述符，一旦某个"),s("strong",[t._v("描述符就绪")]),t._v("（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但"),s("strong",[t._v("select，poll，epoll")]),t._v("本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。")]),t._v(" "),s("p",[t._v("大致流程：")]),t._v(" "),s("p",[t._v("多个网络连接的 IO 可以注册到一个复用器（select）上，当用户进程调用了 select，那么整个进程会被阻塞。同时，内核会**“监视”** select 负责的所有 socket，当任何一个 socket 中的数据准备好了，select 就会返回。这个时候用户进程再调用 read 操作，将数据从内核中拷贝到用户进程。")]),t._v(" "),s("p",[t._v("优点：")]),t._v(" "),s("ul",[s("li",[t._v("在"),s("strong",[t._v("一个线程内可以同时处理多个IO请求")]),t._v("，从而减小系统的开销，而在同步阻塞模型中，必须通过"),s("strong",[t._v("多线程")]),t._v("的方式才能达到这个目的。")])]),t._v(" "),s("h1",{attrs:{id:"select-poll-epoll"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#select-poll-epoll"}},[t._v("#")]),t._v(" select/poll/epoll")]),t._v(" "),s("p",[t._v("I/O多路复用：select/poll/epoll")]),t._v(" "),s("p",[t._v("比如，select方法会一直阻塞直到handle上有事件发生时才会返回。")]),t._v(" "),s("p",[s("strong",[t._v("什么是多路复用？")])]),t._v(" "),s("ul",[s("li",[t._v("多路: 指的是多个socket网络连接;")]),t._v(" "),s("li",[t._v("复用: 指的是复用一个线程；")]),t._v(" "),s("li",[t._v("多路复用主要有三种技术：select，poll，epoll。")])]),t._v(" "),s("p",[t._v("I/O多路复用就是通过一种机制，"),s("strong",[t._v("一个")]),t._v("进程可以监视"),s("strong",[t._v("多个")]),t._v("描述符（一般是"),s("strong",[t._v("读就绪或者写就绪")]),t._v("），一旦某个描述符就绪，能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。")]),t._v(" "),s("p",[t._v("fd（file descriptor）：文件描述符")]),t._v(" "),s("h2",{attrs:{id:"select"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#select"}},[t._v("#")]),t._v(" select")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("select")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" nfds"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" fd_set "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("readfds"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" fd_set "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("writefds"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" fd_set "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("exceptfds"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("timeval")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("timeout"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[s("strong",[t._v("参数")])]),t._v(" "),s("ul",[s("li",[t._v("nfds：指定被监听的文件描述符的总数，通常被设置为select监听的所有文件描述符中最大值+1")]),t._v(" "),s("li",[t._v("readfds：指向"),s("strong",[t._v("可读事件")]),t._v("对应的文件描述符集合")]),t._v(" "),s("li",[t._v("writefds：指向"),s("strong",[t._v("可写事件")]),t._v("对应的文件描述符集合")]),t._v(" "),s("li",[t._v("exceptfds：指向"),s("strong",[t._v("异常事件")]),t._v("对应的文件描述符集合")]),t._v(" "),s("li",[t._v("timeout：设置select函数的超时时间（s、us），若调用失败，timeout的值是不确定的，所以说不能完全信任该值。")])]),t._v(" "),s("p",[t._v("注：fd_set结构体仅包含一个"),s("strong",[t._v("整型数组")]),t._v("，该数组的每一个元素的"),s("strong",[t._v("每一位")]),t._v("(bit)标记一个文件描述符，fd_set能容纳的文件描述符数量由FD_SETSIZE指定，这就限制了select能同时处理文件描述符的总量。")]),t._v(" "),s("p",[s("strong",[t._v("原理")])]),t._v(" "),s("p",[t._v("select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会"),s("strong",[t._v("阻塞")]),t._v("，直到有描述符"),s("strong",[t._v("就绪")]),t._v("（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。")]),t._v(" "),s("p",[s("strong",[t._v("优点")])]),t._v(" "),s("ul",[s("li",[t._v("良好跨平台性：select目前几乎在所有的平台上都支持")])]),t._v(" "),s("p",[s("strong",[t._v("缺点")])]),t._v(" "),s("ul",[s("li",[t._v("单个进程能够监视的文件描述符的数量存在最大限制，32位机默认是1024，64位机默认是2048，虽然可以通过修改FD_SETSIZE提高限制，但会降低效率；")]),t._v(" "),s("li",[t._v("对socket进行线性扫描，即采用轮询的方法，效率较低，时间复杂度为O（N）；")]),t._v(" "),s("li",[t._v("由于select需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。")])]),t._v(" "),s("h2",{attrs:{id:"poll"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#poll"}},[t._v("#")]),t._v(" poll")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("poll")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("pollfd")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("fds"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" nfds"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" timeout"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[s("strong",[t._v("参数")])]),t._v(" "),s("ul",[s("li",[t._v("fds：select使用三个位示图来表示三个fdset，而poll使用一个 "),s("strong",[t._v("pollfd的指针")]),t._v("实现。")]),t._v(" "),s("li",[t._v("nfds：指定"),s("strong",[t._v("被监听事件集合")]),t._v("fds的大小")]),t._v(" "),s("li",[t._v("timeout：指定poll的超时值（ms）")])]),t._v(" "),s("p",[s("strong",[t._v("原理")])]),t._v(" "),s("p",[t._v("poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。它是"),s("strong",[t._v("水平触发")]),t._v("。")]),t._v(" "),s("p",[s("strong",[t._v("优点")])]),t._v(" "),s("ul",[s("li",[t._v("没有最大连接数的限制，因为它是基于"),s("strong",[t._v("链表")]),t._v("来"),s("strong",[t._v("存储")]),t._v("的，")])]),t._v(" "),s("p",[s("strong",[t._v("缺点")])]),t._v(" "),s("ul",[s("li",[t._v("大量的fd的数组被整体复制于用户态和内核地址空间之间，开销大。")]),t._v(" "),s("li",[t._v("对socket进行线性扫描，即采用轮询的方法，效率较低，时间复杂度为O（N）。")])]),t._v(" "),s("h2",{attrs:{id:"epoll"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#epoll"}},[t._v("#")]),t._v(" epoll")]),t._v(" "),s("p",[s("strong",[t._v("原理")])]),t._v(" "),s("ul",[s("li",[t._v("epoll是在2.6内核中提出的，是select和poll的增强版本。")]),t._v(" "),s("li",[t._v("epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。")]),t._v(" "),s("li",[t._v("epoll使用事件的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。")])]),t._v(" "),s("p",[s("strong",[t._v("优点")])]),t._v(" "),s("ul",[s("li",[t._v("没有最大并发连接的限制：能打开的fd的上限远大于1024（1G的内存上能监听约10万个端口）；")]),t._v(" "),s("li",[t._v("效率提升：不是轮询的方式，不会随fd数目的增加效率下降。只有活跃可用的FD才会调用callback函数；")]),t._v(" "),s("li",[t._v("内存拷贝：利用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，在用户空间和内核空间的copy只需一次。mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销；")]),t._v(" "),s("li",[t._v("EPOLLONESHOT事件：对于注册了该事件的文件描述符，内核最多触发其上注册的一个可读、可写或异常事件，且只触发一次，除非使用epoll_ctl函数重置该事件。")])]),t._v(" "),s("p",[s("strong",[t._v("LT与ET")])]),t._v(" "),s("p",[t._v("LT(level triggered "),s("strong",[t._v("水平触发")]),t._v(")模式（默认）：")]),t._v(" "),s("ul",[s("li",[t._v("当epoll_wait检测到描述符事件（可读或可写）发生并将此事件通知应用程序，可以对这个就绪的fd进行IO操作。如果不作任何操作。下次调用epoll_wait时，会再次响应应用程序并通知此事件。")]),t._v(" "),s("li",[t._v("LT同时支持block和no-block socket")])]),t._v(" "),s("p",[t._v("ET(edge-triggered "),s("strong",[t._v("边缘触发")]),t._v(")模式（高速工作方式）：")]),t._v(" "),s("ul",[s("li",[t._v("当epoll_wait检测到描述符事件（可读–>可写或可写–>可读）发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。")]),t._v(" "),s("li",[t._v("ET只支持no-block socket。")]),t._v(" "),s("li",[t._v("ET减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免文件描述符的饥饿情况发生。")])])])}),[],!1,null,null,null);s.default=v.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{416:function(v,_,t){"use strict";t.r(_);var e=t(2),a=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"java线程的五种状态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java线程的五种状态"}},[v._v("#")]),v._v(" Java线程的五种状态")]),v._v(" "),_("img",{attrs:{src:"https://billrepo.oss-cn-hangzhou.aliyuncs.com/doc-img/image-20220921101242281.png"}}),v._v(" "),_("p",[v._v("线程共包括以下 5 种状态:")]),v._v(" "),_("p",[_("strong",[v._v("1. 新建状态(New):")]),v._v(" 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。")]),v._v(" "),_("p",[_("strong",[v._v("2. 就绪状态(Runnable):")]),v._v(" 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。")]),v._v(" "),_("p",[_("strong",[v._v("3. 运行状态(Running):")]),v._v(" 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。")]),v._v(" "),_("p",[_("strong",[v._v("4. 阻塞状态(Blocked):")]),v._v(" 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：")]),v._v(" "),_("ul",[_("li",[v._v("(01) "),_("strong",[v._v("等待")]),v._v("阻塞 -- 通过调用线程的wait()方法，让线程等待某工作的完成。")]),v._v(" "),_("li",[v._v("(02) "),_("strong",[v._v("同步")]),v._v("阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。")]),v._v(" "),_("li",[v._v("(03) "),_("strong",[v._v("其他")]),v._v("阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。")])]),v._v(" "),_("p",[_("strong",[v._v("5. 死亡状态(Dead):")]),v._v(" 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。")]),v._v(" "),_("h2",{attrs:{id:"wait和sleep"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#wait和sleep"}},[v._v("#")]),v._v(" wait和sleep")]),v._v(" "),_("p",[v._v("wait 是 Object 类的方法，sleep 是 Thread 类的静态方法。")]),v._v(" "),_("p",[_("strong",[v._v("java.lang.Object  ->  wait()方法")]),v._v("   wait 是让获得对象锁的线程实现等待，前提是要楚获得对象的锁，所以是类的方法。")]),v._v(" "),_("ul",[_("li",[v._v("使用 wait 方法则必须放在 "),_("strong",[v._v("synchronized 块")]),v._v("里面，同样需要捕获 InterruptedException 异常，并且需要"),_("strong",[v._v("获取对象的锁")]),v._v("。")]),v._v(" "),_("li",[v._v("当一个线程执行wait方法时，它就进入到一个和该对象相关的"),_("strong",[v._v("等待池")]),v._v("(等待阻塞)，同时"),_("strong",[v._v("释放对象的锁")]),v._v("，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程。")]),v._v(" "),_("li",[v._v("wait 可以释放当前线程对 lock 对象锁的持有，而 sleep 则不会。")])]),v._v(" "),_("hr"),v._v(" "),_("p",[_("strong",[v._v("java.lang.Thread  -> sleep()方法")]),v._v("   sleep 是让当前线程休眠，不涉及到对象类，也不需要获得对象的锁，所以是线程类的方法。")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("使用 sleep 方法可以让让当前线程休眠，时间一到当前线程进入就绪状态，在任何地方都能使用，但需要"),_("strong",[v._v("捕获 InterruptedException 异常")]),v._v("。")])]),v._v(" "),_("li",[_("p",[v._v("因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。")])]),v._v(" "),_("li",[_("p",[v._v("sleep()不会释放对象锁")])])]),v._v(" "),_("h2",{attrs:{id:"join和yield"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#join和yield"}},[v._v("#")]),v._v(" join和yield")]),v._v(" "),_("p",[_("strong",[v._v("java.lang.Thread  -> join()方法")])]),v._v(" "),_("ul",[_("li",[v._v("可以使得一个线程在另一个线程结束后再执行。")])]),v._v(" "),_("p",[v._v("比如在线程B中调用了线程A的Join()方法，线程B暂时"),_("strong",[v._v("阻塞")]),v._v("，直到线程A执行完毕后，才会继续执行线程B。")]),v._v(" "),_("hr"),v._v(" "),_("p",[_("strong",[v._v("java.lang.Thread  -> yield方法")]),v._v("      yield：让步")]),v._v(" "),_("ul",[_("li",[v._v("暂停当前正在执行的线程，并执行其他线程。")]),v._v(" "),_("li",[v._v("当前正在执行的线程"),_("strong",[v._v("由运行状态变为就绪状态")]),v._v("。")])]),v._v(" "),_("blockquote",[_("p",[v._v("yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。")])])])}),[],!1,null,null,null);_.default=a.exports}}]);
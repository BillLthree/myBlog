(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{424:function(v,_,t){"use strict";t.r(_);var o=t(2),s=Object(o.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引"}},[v._v("#")]),v._v(" 索引")]),v._v(" "),_("p",[v._v("索引是一种"),_("strong",[v._v("排好序")]),v._v("的"),_("strong",[v._v("数据结构")]),v._v("，用于"),_("strong",[v._v("快速查询数据")]),v._v("。")]),v._v(" "),_("blockquote",[_("p",[v._v("数据库的索引类似书籍的"),_("strong",[v._v("目录")]),v._v("。索引使查询能快速到达计算机的某个位置去搜寻数据，而不必对所有数据进行扫描。索引的建立，可以大大提高"),_("strong",[v._v("数据查询")]),v._v("的效率。")])]),v._v(" "),_("p",[v._v("它能够单独地存储在计算机的"),_("strong",[v._v("磁盘")]),v._v("上，包含着对相关数据表中所有数据的"),_("strong",[v._v("引用指针")]),v._v("。通过索引可以快速定位并查询出数据表中的一行或多行数据，而不必进行全表扫描。")]),v._v(" "),_("p",[v._v("索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。")]),v._v(" "),_("p",[v._v("在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了"),_("strong",[v._v("B+树")]),v._v("作为索引的数据结构。但是，两者的实现方式不太一样。")]),v._v(" "),_("blockquote",[_("p",[v._v("MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“"),_("strong",[v._v("非聚簇索引（非聚集索引）")]),v._v("”。")]),v._v(" "),_("p",[v._v("InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“"),_("strong",[v._v("聚簇索引（聚集索引）")]),v._v("”，而其余的索引都作为 "),_("strong",[v._v("辅助索引")]),v._v(" ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。")])]),v._v(" "),_("p",[v._v("https://www.jianshu.com/p/28d18bc1010d 什么情况下使用索引")]),v._v(" "),_("h2",{attrs:{id:"使用索引的优缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用索引的优缺点"}},[v._v("#")]),v._v(" 使用索引的优缺点")]),v._v(" "),_("p",[_("strong",[v._v("优点")]),v._v(" ：")]),v._v(" "),_("ul",[_("li",[v._v("使用索引可以大大加快数据的查询速度（大大减少查询的数据量）, 这也是创建索引的最主要的原因。")]),v._v(" "),_("li",[v._v("通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。")])]),v._v(" "),_("p",[_("strong",[v._v("缺点")]),v._v(" ：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("创建")]),v._v("索引和"),_("strong",[v._v("维护")]),v._v("索引需要"),_("strong",[v._v("耗费许多时间")]),v._v("。当对表中的数据进行增删改的时候，如果数据有索引，那么"),_("strong",[v._v("索引也需要动态的修改")]),v._v("，会降低 SQL 执行效率。")]),v._v(" "),_("li",[v._v("索引需要使用物理文件存储，也会耗费一定空间。")])]),v._v(" "),_("h2",{attrs:{id:"最左前缀匹配原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#最左前缀匹配原则"}},[v._v("#")]),v._v(" 最左前缀匹配原则")]),v._v(" "),_("p",[v._v("联合索引：多列值组成一个索引，专门用于组合搜索。")]),v._v(" "),_("p",[v._v("首先，需要明确的是：最左前缀原则是发生在联合索引上的，只有联合索引才会有所谓的左和右之分。")]),v._v(" "),_("p",[v._v("在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的"),_("strong",[v._v("最左边")]),v._v("开始匹配。")]),v._v(" "),_("h2",{attrs:{id:"索引类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引类型"}},[v._v("#")]),v._v(" 索引类型")]),v._v(" "),_("p",[v._v("按照底层存储方式角度划分：")]),v._v(" "),_("ul",[_("li",[v._v("聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的"),_("strong",[v._v("主键")]),v._v("索引就属于聚簇索引，也即"),_("strong",[v._v("找到索引就找到了数据")]),v._v("。")]),v._v(" "),_("li",[v._v("非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，非聚簇索引也叫"),_("strong",[v._v("二级索引")]),v._v("(辅助索引)，也就是说找到了索引但没找到数据，需要根据索引上的值(主键)"),_("strong",[v._v("再次回表查询")]),v._v("。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。")])]),v._v(" "),_("blockquote",[_("p",[v._v("在从非主键索引树搜索回到主键索引树搜索的过程称为：回表。")])]),v._v(" "),_("p",[v._v("按照应用维度划分：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("普通索引(INDEX)：最基本的索引，没有任何限制")])]),v._v(" "),_("li",[_("p",[v._v('唯一索引(UNIQUE])：与"普通索引"类似，不同的就是：索引列的值必须唯一，但允许有空值。')])]),v._v(" "),_("li",[_("p",[v._v("主键索引(PRIMARY)：它 是一种特殊的唯一索引，不允许有空值。")])]),v._v(" "),_("li",[_("p",[v._v("覆盖索引：一个索引包含（或者说覆盖）所有"),_("strong",[v._v("需要查询的字段的值")]),v._v("。")]),v._v(" "),_("blockquote",[_("p",[v._v("即从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，"),_("strong",[v._v("避免了回表的产生")]),v._v("，减少了树的搜索次数，显著提升性能。")]),v._v(" "),_("p",[v._v("https://juejin.cn/post/6844903967365791752#heading-3")])])]),v._v(" "),_("li",[_("p",[v._v("联合索引：多列值组成一个索引，专门用于组合搜索，"),_("strong",[v._v("遵循”最左前缀“原则")]),v._v("。")]),v._v(" "),_("p",[v._v("优点：减少空间开销（1个顶3个）、实现覆盖索引（避免回表）、效率高（索引列越多,通过联合索引筛选出的数据越少，"),_("strong",[v._v("定位越快")]),v._v("）")]),v._v(" "),_("p",[v._v("当创建(col1,col2,col3)联合索引时，相当于创建了(col)单列索引，(clo1,clo2)联合索引以及(col1,col2,col3)联合索引；想要索引生效，只能使用 col1 和 col1,col2 和col1,col2,col3 三种组合；当然，col1,col3组合也可以，但实际上只用到了col1的索引，col3并没有用到！")]),v._v(" "),_("blockquote",[_("p",[v._v("如果我们的where查询条件中没有col1这个筛选条件，那么mysql默认认为我们不希望通过索引查询。")]),v._v(" "),_("p",[v._v("我们在使用联合索引的时候需要注意索引的使用顺序问题。")])])]),v._v(" "),_("li",[_("p",[v._v("全文索引：对文本的内容进行分词，进行搜索。目前只有 "),_("code",[v._v("CHAR")]),v._v("、"),_("code",[v._v("VARCHAR")]),v._v(" ，"),_("code",[v._v("TEXT")]),v._v(" 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。")])])]),v._v(" "),_("h2",{attrs:{id:"b树和b-树区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#b树和b-树区别"}},[v._v("#")]),v._v(" B树和B+树区别")]),v._v(" "),_("p",[_("strong",[v._v("为什么 MySQL 没有使用哈希表（HashMap）作为索引的数据结构呢？")])]),v._v(" "),_("p",[v._v("主要是因为 Hash 索引不支持"),_("strong",[v._v("顺序和范围查询")]),v._v("。并且，每次 IO 只能取一个。")]),v._v(" "),_("p",[_("strong",[v._v("B树和B+树区别")]),v._v("：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("节点存的东西不同")]),v._v(" "),_("p",[v._v("B 树的所有节点既存放键(key) 也存放数据，而 B+树只有"),_("strong",[v._v("叶子节点")]),v._v("存放 key 和 data，其他节点内只存放 key；")])]),v._v(" "),_("li",[_("p",[v._v("叶子节点逻辑结构不同")]),v._v(" "),_("p",[v._v("B 树的叶子节点都是独立的；B+树的相邻叶子节点之间有"),_("strong",[v._v("指针")]),v._v("相连，组成一个链表（"),_("strong",[v._v("Innodb中")]),v._v("，每个叶子节点就是一个数据页，数据页之间形成双向循环链表，而一个叶子节点内的数据之间组成一个单向链表）；")])]),v._v(" "),_("li",[_("p",[v._v("查找过程不同")]),v._v(" "),_("p",[v._v("B 树的查找过程是做"),_("strong",[v._v("二分查找")]),v._v("，类似二叉排序树，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就"),_("strong",[v._v("很稳定")]),v._v("了，任何查找都是"),_("strong",[v._v("从根节点到叶子节点")]),v._v("的过程，叶子节点的顺序检索很明显。")])])]),v._v(" "),_("p",[_("strong",[v._v("B+树的优点")])]),v._v(" "),_("ol",[_("li",[_("p",[v._v("磁盘IO次数少。")]),v._v(" "),_("p",[v._v("相比B树，B+树的非叶子节点只存放了key，没存数据，所以当把索引放入同样大小的磁盘块时，B+树一次性放入的索引更多，"),_("strong",[v._v("一次磁盘加载的关键字更多")]),v._v("，所以磁盘IO次数减少。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("范围查询")]),v._v("的能力很强。")]),v._v(" "),_("p",[v._v("更有利于对数据库、表的扫描，只需要遍历叶子节点。")])]),v._v(" "),_("li",[_("p",[v._v("数据的"),_("strong",[v._v("查询效率更稳定")]),v._v("。")])])]),v._v(" "),_("h2",{attrs:{id:"为什么用b-树作索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么用b-树作索引"}},[v._v("#")]),v._v(" 为什么用B+树作索引")]),v._v(" "),_("p",[_("strong",[v._v("MySQL")]),v._v(" "),_("strong",[v._v("为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么？")])]),v._v(" "),_("p",[v._v("操作系统一般将内存和磁盘分割成固定大小的块，每一块称为每一页，内存和磁盘以页为单位交换数据，数据库系统将索引的一个节点的大小设置为页的大小，使得一次I/O就完全载入一个节点，这一页的大小为16K，16*1024 字节。")]),v._v(" "),_("p",[v._v("B 树的所有节点既存放键(key) 也存放数据("),_("strong",[v._v("实际存的是指向数据的指针")]),v._v(")，而 B+树只有"),_("strong",[v._v("叶子节点")]),v._v("存放 key 和 data，其他节点内只存放 key")]),v._v(" "),_("p",[v._v("B+树中各页之间通过双向链表连接，叶子节点中的数据是通过单向链表连接的")]),v._v(" "),_("p",[v._v("B树不管叶子节点还是非叶子节点都会保存数据，这样导致在非叶子节点中能保存的指针数量变少，指针少的情况下要保存大量数据，只能增加树的高度，"),_("strong",[v._v("导致IO次数变多")]),v._v("，查询性能变低")]),v._v(" "),_("p",[v._v("MyISAM中的B+树索引实现略有不同，叶子节点不存数据，存放数据的文件地址")])])}),[],!1,null,null,null);_.default=s.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{421:function(v,_,n){"use strict";n.r(_);var t=n(2),a=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("在java程序中，创建对象的方式有多种。最常用的方式是new语句，还可以通过反射机制、Object.clone方法、反序列化以及Unsafe.allocateInstance方法来新建对象。")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("new语句和反射机制是通过调用"),_("strong",[v._v("构造器")]),v._v("来初始化实例；")])]),v._v(" "),_("li",[_("p",[v._v("clone和反序列化通过直接复制已有的数据来初始化新建对象的实例字段；")])]),v._v(" "),_("li",[_("p",[v._v("allocateInst直接操作内存创建对象。")])])]),v._v(" "),_("p",[_("strong",[v._v("new对象创建过程")]),v._v("：")]),v._v(" "),_("p",[v._v("1、类加载检查")]),v._v(" "),_("p",[v._v("2、分配内存")]),v._v(" "),_("p",[v._v("3、初始化零值")]),v._v(" "),_("p",[v._v("4、设置对象头")]),v._v(" "),_("p",[v._v("5、调用构造函数真正初始化")]),v._v(" "),_("p",[v._v("一共5步：")]),v._v(" "),_("p",[v._v("1.当Java虚拟机遇到一条new字节码指令时，首先将去检查这个类是否已经被加载。如果没有，先要进行"),_("strong",[v._v("类加载过程（加载->连接->初始化->使用->销毁）")]),v._v("。")]),v._v(" "),_("p",[v._v("2.接下来虚拟机"),_("strong",[v._v("为新生对象分配内存")]),v._v("。对象所需内存大小在类加载完成后便可以确定。")]),v._v(" "),_("ul",[_("li",[v._v("如果内存空间是规整的，则通过"),_("strong",[v._v("指针碰撞")]),v._v("来为对象分配内存，未被使用和已被使用堆内存分开来放置在两侧，中间通过一个指针来作为分界的指示器，分配内存时只需将分界指针往未使用内存空间移动出对象所需空间即可。")]),v._v(" "),_("li",[v._v("如果内存空间是不规整的，则通过"),_("strong",[v._v("空闲列表")]),v._v("来分配内存，虚拟机维护一个列表来记录哪些内存空间是未使用的，分配时在列表中找一个足够大的空间划分给该对象。")])]),v._v(" "),_("p",[v._v("具体通过哪种方式来给对象分配内存是由虚拟机的垃圾回收器来决定的，因为有些垃圾回收器回收内存之后内存是规整的。另外一些垃圾回收器回收之后内存是不规整的，会产生大量内存碎片。")]),v._v(" "),_("blockquote",[_("p",[v._v("对象内存的分配是多线程并发操作的，所以会有并发问题")]),v._v(" "),_("ul",[_("li",[v._v("java虚拟机是采用"),_("strong",[v._v("CAS+失败重试")]),v._v("的方式保证更新操作的原子性")]),v._v(" "),_("li",[v._v("另外一种是把内存分配的动作按照线程划分在不同的空间之中进 行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，分配新的缓存区时才需要同步锁定。")])])]),v._v(" "),_("p",[v._v("3.内存分配完成之后，虚拟机必须把分配的内存区域（对象头除外）都初始化为零值（第一次初始化：初始化为"),_("strong",[v._v("数据类型的默认值")]),v._v("）。这步操作保证了对象的实例字段 在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。")]),v._v(" "),_("p",[v._v("4.进行对象的对象头设置，设置"),_("strong",[v._v("类型指针")]),v._v("指向方法区的"),_("strong",[v._v("类型元数据")]),v._v("，java虚拟机通过这个指针可以知道这个对象是哪个类的实例。设置mark word值，涵盖对象的hashcode，GC分代年龄和锁标识。")]),v._v(" "),_("p",[v._v("5.调用构造函数"),_("strong",[v._v("真正初始化对象")]),v._v("，为对象字段"),_("strong",[v._v("赋值")]),v._v("（程序员自定义的值）。")]),v._v(" "),_("ul",[_("li",[v._v("提到构造器，就不得不提到 Java 对构造器的诸多约束。首先，如果一个类没有定义任何构造器的话， Java 编译器会自动添加一个无参数的构造器。")]),v._v(" "),_("li",[v._v("子类的构造器需要调用父类的构造器。当我们调用一个构造器时，它将优先调用父类的构造器，直至 Object 类。这些构造器的调用者皆为同一对象，也就是通过 new 指令新建而来的对象。")]),v._v(" "),_("li",[v._v("通过 new 指令新建出来的对象，它的内存其实涵盖了所有父类中的实例字段。也就是说，虽然子类无法访问父类的私有实例字段，或者子类的实例字段隐藏了父类的同名实例字段，但是子类的实例还是会为这些父类实例字段分配内存的。")])]),v._v(" "),_("p",[v._v("经过上述过程之后，一个完整的对象就创建出来了。")])])}),[],!1,null,null,null);_.default=a.exports}}]);
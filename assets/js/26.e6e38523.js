(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{425:function(e,n,t){"use strict";t.r(n);var v=t(2),o=Object(v.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"netty核心组件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#netty核心组件"}},[e._v("#")]),e._v(" netty核心组件")]),e._v(" "),n("p",[e._v("netty基于 java NIO，采用"),n("strong",[e._v("主从Reactor 多线程")]),e._v("模式。")]),e._v(" "),n("p",[e._v("https://cloud.tencent.com/developer/article/1754078   深度解析 Netty 架构与原理")]),e._v(" "),n("h2",{attrs:{id:"netty线程模型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#netty线程模型"}},[e._v("#")]),e._v(" netty线程模型")]),e._v(" "),n("ul",[n("li",[e._v("bossGroup 用于监听客户端连接，专门负责与客户端创建连接，并"),n("strong",[e._v("把连接注册到 workerGroup 的 Selector 中")]),e._v("。")]),e._v(" "),n("li",[e._v("workerGroup 用于处理每一个连接发生的读写事件。")])]),e._v(" "),n("p",[e._v("1）Netty 抽象出两组线程池：BossGroup 和 WorkerGroup，也可以叫做 BossNioEventLoopGroup 和 WorkerNioEventLoopGroup。每个线程池中都有 NioEventLoop 线程。BossGroup 中的线程专门负责"),n("strong",[e._v("和客户端建立连接")]),e._v("，WorkerGroup 中的线程专门负责"),n("strong",[e._v("处理连接上的读写")]),e._v("。BossGroup 和 WorkerGroup 的类型都是 NioEventLoopGroup。")]),e._v(" "),n("p",[e._v("2）NioEventLoopGroup 相当于一个事件循环组，这个组中含有多个事件循环，每个事件循环就是一个 NioEventLoop。")]),e._v(" "),n("p",[e._v("3）NioEventLoop 表示"),n("strong",[e._v("一个不断循环的执行事件处理的线程")]),e._v("，每个 NioEventLoop 都"),n("strong",[e._v("包含一个 Selector")]),e._v("，用于监听注册在其上的 Socket 网络连接（Channel）。")]),e._v(" "),n("p",[e._v("4）NioEventLoopGroup 可以含有多个线程，即可以含有多个 NioEventLoop。")]),e._v(" "),n("p",[e._v("5）每个 BossNioEventLoop 中循环执行以下三个步骤：")]),e._v(" "),n("p",[e._v("5.1）select：轮训注册在其上的 "),n("strong",[e._v("ServerSocketChannel")]),e._v(" 的 accept 事件（OP_ACCEPT 事件）")]),e._v(" "),n("p",[e._v("5.2）processSelectedKeys："),n("strong",[e._v("处理 accept 事件，与客户端建立连接")]),e._v("，"),n("strong",[e._v("生成一个 NioSocketChannel，并将其注册到某个 WorkerNioEventLoop 上的 Selector 上")])]),e._v(" "),n("p",[e._v("5.3）runAllTasks：再去以此循环处理任务队列中的其他任务")]),e._v(" "),n("p",[e._v("6）每个 WorkerNioEventLoop 中循环执行以下三个步骤：")]),e._v(" "),n("p",[e._v("6.1）select：轮训注册在其上的 NioSocketChannel 的 read/write 事件（OP_READ/OP_WRITE 事件）")]),e._v(" "),n("p",[e._v("6.2）processSelectedKeys："),n("strong",[e._v("在对应的 NioSocketChannel 上处理 read/write 事件")])]),e._v(" "),n("p",[e._v("6.3）runAllTasks：再去以此循环处理任务队列中的其他任务")]),e._v(" "),n("p",[e._v("7）在以上两个processSelectedKeys步骤中，会使用 Pipeline（"),n("strong",[e._v("管道是一个存放ChannelHandler的list集合")]),e._v("），Pipeline 中"),n("strong",[e._v("引用了 Channel")]),e._v("，即通过 Pipeline 可以获取到对应的 Channel，Pipeline 中维护了很多的处理器（拦截处理器、过滤处理器、自定义处理器等）。这里暂时不详细展开讲解 Pipeline。")]),e._v(" "),n("h2",{attrs:{id:"bytebuf"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bytebuf"}},[e._v("#")]),e._v(" ByteBuf")]),e._v(" "),n("p",[e._v("Netty 是面向 ByteBuf 来传输数据的。ByteBuf 是一个"),n("strong",[e._v("字节容器")]),e._v("，内部是一个字节数组，提供了常见 api。")]),e._v(" "),n("h2",{attrs:{id:"启动器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#启动器"}},[e._v("#")]),e._v(" 启动器")]),e._v(" "),n("p",[e._v("Boostrap：客户端的"),n("strong",[e._v("启动器")]),e._v("(启动引导类)，帮助 Netty 使用者更加方便地"),n("strong",[e._v("组装")]),e._v("和"),n("strong",[e._v("配置")]),e._v(" Netty ，也可以更方便地启动 Netty 应用程序。")]),e._v(" "),n("p",[e._v("ServerBoostrap：服务端的启动器。")]),e._v(" "),n("h2",{attrs:{id:"channel"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#channel"}},[e._v("#")]),e._v(" Channel")]),e._v(" "),n("p",[e._v("Channel 是 Netty 的"),n("strong",[e._v("网络通信组件")]),e._v("(网络操作抽象类)，客户端和服务端建立连接之后会维持一个 Channel。在传统的网络编程中，作为核心类的 Socket ，它对程序员来说并不是那么友好，直接使用其成本还是稍微高了点。而 Netty 的 Channel 则"),n("strong",[e._v("提供一系列的 API")]),e._v(" ，它大大降低了直接与 Socket 进行操作的复杂性。")]),e._v(" "),n("p",[e._v("Channel 功能：除了包括基本的 "),n("strong",[e._v("I/O 操作")]),e._v("，如 bind、connect、read、write 之外，还包括了 Netty 框架相关的一些功能，如获取该 Channel 的 EventLoop 。")]),e._v(" "),n("h2",{attrs:{id:"eventloop"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#eventloop"}},[e._v("#")]),e._v(" EventLoop")]),e._v(" "),n("p",[e._v("Netty 基于事件驱动模型，使用不同的事件来通知我们状态的改变或者操作状态的改变。"),n("strong",[e._v("EventLoop")]),e._v("在整个连接的生命周期里"),n("strong",[e._v("对事件进行处理")]),e._v("。")]),e._v(" "),n("p",[e._v("EventLoop(事件循环)：负责"),n("strong",[e._v("监听网络事件")]),e._v("并"),n("strong",[e._v("调用事件处理器")]),e._v("进行相关I/O操作的处理。")]),e._v(" "),n("p",[e._v("Channel 和 EventLoop 的关系： Channel 是Netty的网络操作抽象类，EventLoop 负责处理注册到其上的Channel 的 I/O 操作，两者配合参与 I/O 操作。")]),e._v(" "),n("ul",[n("li",[e._v("一个 EventLoopGroup 包含一个或多个 EventLoop。")]),e._v(" "),n("li",[e._v("一个 EventLoop 在它的生命周期内只能与一个Thread绑定(保证线程安全)。")]),e._v(" "),n("li",[e._v("所有由 EnventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理。")]),e._v(" "),n("li",[e._v("一个 Channel 在它的生命周期内只能注册于一个 EventLoop。")]),e._v(" "),n("li",[e._v("一个 EventLoop 可被分配至一个或多个 Channel 。")])]),e._v(" "),n("p",[n("strong",[e._v("EventLoop 表示一个不断循环的执行事件处理的线程，每个 NioEventLoop 都包含一个 Selector，用于监听注册在其上的 Socket 网络连接（Channel）。")])]),e._v(" "),n("h2",{attrs:{id:"channelhandler"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#channelhandler"}},[e._v("#")]),e._v(" ChannelHandler")]),e._v(" "),n("p",[e._v("ChannelHandler(消息处理器)：是消息的具体处理器，主要负责处理客户端/服务端接收和发送的数据。")]),e._v(" "),n("p",[e._v("入站和出站：")]),e._v(" "),n("ul",[n("li",[e._v("入站消息会被解码：从字节转换为另一种格式（比如Java对象）；与输入数据有关，"),n("strong",[e._v("入站会从先读取(转码)，再执行入站的Handler")])]),e._v(" "),n("li",[e._v("如果是出站消息，它会被编码成字节。与输出数据有关，"),n("strong",[e._v("出站会先执行出站的Handler，再写出(转码)")])])]),e._v(" "),n("p",[e._v("ChannelHandler下主要是两个子接口")]),e._v(" "),n("ul",[n("li",[e._v("ChannelInboundHandler(入站): 处理输入数据。")])]),e._v(" "),n("p",[e._v("​       适配器: ChannelInboundHandlerAdapter（适配器设计模式）")]),e._v(" "),n("ul",[n("li",[e._v("ChannelOutboundHandler(出站): 处理输出数据")])]),e._v(" "),n("p",[e._v("​       适配器: ChannelOutboundHandlerAdapter")]),e._v(" "),n("p",[e._v("ChannelIn(Out)boundHandlerAdapter就是设配器模式的产物,让它去实现上面接口的它所有方法。当我们自己写自定义的Handler时,只要继承这个Adapter,就无须重写上面接口的所有方法了。")]),e._v(" "),n("h2",{attrs:{id:"channelpipeline"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#channelpipeline"}},[e._v("#")]),e._v(" ChannelPipeline")]),e._v(" "),n("p",[e._v("ChannelPipeline 可认为是一个管道，通俗理解是"),n("strong",[e._v("保存 ChannelHandler 的 List 集合")]),e._v("。用于处理或截获"),n("strong",[e._v("通道channel")]),e._v("的接收和发送数据。它提供了一种高级的截取过滤模式（类似serverlet中的filter功能），让用户可以在ChannelPipeline中完全控制一个事件以及如何处理ChannelHandler与ChannelPipeline的交互。")]),e._v(" "),n("p",[e._v("并将pipeline附加到channel中。下图描述ChannelHandler与pipeline中的关系，一个IO操作可以由一个ChannelInboundHandler（处理入站IO）或ChannelOutboundHandler（处理出站IO）进行处理。")]),e._v(" "),n("h2",{attrs:{id:"channefuture"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#channefuture"}},[e._v("#")]),e._v(" ChanneFuture")]),e._v(" "),n("p",[e._v("Netty是异步事件驱动的框架，网络IO模型采用的是Java NIO (IO多路复用)。")]),e._v(" "),n("p",[e._v("异步事件驱动框架体现在"),n("strong",[e._v("所有的I/O操作是异步的")]),e._v("，所有的IO调用会"),n("strong",[e._v("立即返回")]),e._v("，并不保证调用成功与否，但是调用会返回ChannelFuture，Netty 提供了 ChannelFuture 接口，通过该接口的 addListener() 方法注册一个 ChannelFutureListener，当操作执行成功或者失败时，监听就会自动触发返回结果。")])])}),[],!1,null,null,null);n.default=o.exports}}]);
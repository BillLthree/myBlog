(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{429:function(v,_,t){"use strict";t.r(_);var s=t(2),e=Object(s.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"设计秒杀系统"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计秒杀系统"}},[v._v("#")]),v._v(" 设计秒杀系统")]),v._v(" "),_("p",[v._v("秒杀系统的业务逻辑非常简单，一般就是下订单减库存，难点在于我们如何保障秒杀能够顺利进行。")]),v._v(" "),_("ul",[_("li",[v._v("秒杀开始的时候，会有大量用户同时参与进来，因此秒杀系统一定要满足 "),_("strong",[v._v("高并发")]),v._v(" 和 "),_("strong",[v._v("高性能")]),v._v(" 。")]),v._v(" "),_("li",[v._v("为了保证秒杀整个流程的顺利进行，整个秒杀系统必须要满足 "),_("strong",[v._v("高可用")]),v._v(" 。")]),v._v(" "),_("li",[v._v("除此之外，由于商品的库存有限，在面对大量订单的情况下，一定不能超卖，我们还需要保证 "),_("strong",[v._v("一致性")])])]),v._v(" "),_("p",[v._v("三高概念解释：")]),v._v(" "),_("blockquote",[_("p",[v._v("高并发简单来说就是能够同时处理很多用户请求;")])]),v._v(" "),_("blockquote",[_("p",[v._v("高性能简单来说就是处理用户的请求速度要快;")])]),v._v(" "),_("blockquote",[_("p",[v._v("高可用简单来说就是我们的系统要在趋近 100% 的时间内都能正确提供服务。")])]),v._v(" "),_("p",[v._v("站在技术层面来思考一下：“设计秒杀系统的过程中需要重点关注哪些问题”")]),v._v(" "),_("ol",[_("li",[v._v("参与秒杀的商品属于热点数据，我们该如何处理热点数据？")]),v._v(" "),_("li",[v._v("商品的库存有限，在面对大量订单的情况下，如何解决超卖的问题？")]),v._v(" "),_("li",[v._v("如果系统用了消息队列，如何保证消息队列不丢失消息？")]),v._v(" "),_("li",[v._v("如何保证秒杀系统的高可用？")]),v._v(" "),_("li",[v._v("如何对项目进行压测？有哪些工具？")])]),v._v(" "),_("h2",{attrs:{id:"高并发-高性能"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#高并发-高性能"}},[v._v("#")]),v._v(" 高并发&高性能")]),v._v(" "),_("h3",{attrs:{id:"热点数据处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#热点数据处理"}},[v._v("#")]),v._v(" 热点数据处理")]),v._v(" "),_("blockquote",[_("p",[v._v("热点数据指的就是某一时间段内被大量访问的数据，比如爆款商品的数据、新闻热点。")])]),v._v(" "),_("p",[_("strong",[v._v("为什么要关注热点数据？")]),v._v(" 热点数据可能仅仅占据系统所有数据的 0.1% ，但是其访问量可能是比其他所有数据之和还要多。不重点处理热点数据，势必会给系统资源消耗带来严峻的挑战。")]),v._v(" "),_("p",[v._v("热点数据的分类？ 根据热点数据的特点，我们通常将其分为两类：")]),v._v(" "),_("ul",[_("li",[v._v("静态热点数据 ：可以提前预测到的热点数据比如要秒杀的商品。")]),v._v(" "),_("li",[v._v("动态热点数据 ： 不能够提前预测到的热点数据，需要通过一些手段动态检测系统运行情况产生。")])]),v._v(" "),_("p",[v._v("处理热点数据的问题的关键：如何找到这些热点数据（或者说热 key），然后将它们存在 jvm 内存（"),_("strong",[v._v("JVM本地缓存")]),v._v("）里。 对于并发量非常一般的系统直接将热点数据存放进"),_("strong",[v._v("缓存")]),v._v("比如 Redis 中就可以了，不过像淘宝、京东这种级别的并发量，如果把某些热点数据放在 Redis 中，直接可能就将整个 Redis 集群给干掉了。")]),v._v(" "),_("p",[v._v("参考："),_("RouterLink",{attrs:{to:"/后端/www.cnblogs.com/xuwc/p/14013060.html"}},[v._v("常见缓存问题处理-缓存热点key")])],1),v._v(" "),_("p",[_("strong",[v._v("如何检测热点数据？")])]),v._v(" "),_("p",[v._v("我了解到的是市面上也有一些类似的中间件，比如京东零售的 "),_("a",{attrs:{href:"https://gitee.com/jd-platform-opensource/hotkey",target:"_blank",rel:"noopener noreferrer"}},[v._v("hotkey"),_("OutboundLink")],1),v._v(" 就是一款专门用于检测热点数据的中间件，它可以毫秒级探测热点数据，毫秒级推送至服务器集群内存。相关阅读："),_("a",{attrs:{href:"https://mp.weixin.qq.com/s/xOzEj5HtCeh_ezHDPHw6Jw",target:"_blank",rel:"noopener noreferrer"}},[v._v("京东毫秒级热 key 探测框架设计与实践，已完美支撑 618 大促"),_("OutboundLink")],1),v._v(" 。")]),v._v(" "),_("p",[v._v("另外，我们平时使用 Redis 做缓存比较多，关于如何快速定位 Redis 热点数据，可以看下"),_("a",{attrs:{href:"https://www.infoq.cn/article/3l3zaq4h8xpnom2glsyi",target:"_blank",rel:"noopener noreferrer"}},[v._v("如何快速定位 Redis 热 key"),_("OutboundLink")],1),v._v("这篇文章。")]),v._v(" "),_("p",[_("strong",[v._v("如何处理热点数据？")]),v._v(" 热点数据一定要放在缓存中，并且最好可以写入到 jvm 内存一份（多级缓存），并设置个过期时间。需要注意写入到 jvm 的热点数据不宜过多，避免内存占用过大，一定要设置到淘汰策略。")]),v._v(" "),_("p",[_("strong",[v._v("为什么还要放在 jvm 内存一份？")]),v._v(" 因为放在 jvm 内存中的"),_("strong",[v._v("数据访问速度是最快")]),v._v("的，不存在什么网络开销。")]),v._v(" "),_("h3",{attrs:{id:"静态资源处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#静态资源处理"}},[v._v("#")]),v._v(" 静态资源处理")]),v._v(" "),_("p",[v._v("将静态资源放到第三方云服务中进行CDN加速，减轻秒杀时的带宽压力，比如阿里云、七牛云等等。实践证明，CDN加速的效果十分明显，对于一些响应不是很快的网站而言，静态资源做了CDN加速后会变得很快，前后响应速度截然不同，是生产中必不可少的一种方式。")]),v._v(" "),_("h2",{attrs:{id:"高可用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#高可用"}},[v._v("#")]),v._v(" 高可用")]),v._v(" "),_("h3",{attrs:{id:"集群化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#集群化"}},[v._v("#")]),v._v(" 集群化")]),v._v(" "),_("p",[v._v("如果我们想要保证系统中某一个组件的高可用，往往需要"),_("strong",[v._v("搭建集群")]),v._v("来避免单点风险，比如说 Nginx 集群、Kafka 集群、Redis 集群。")]),v._v(" "),_("p",[v._v("我们拿 Redis 来举例说明。"),_("strong",[v._v("如果我们需要保证 Redis 高可用的话，该怎么做呢？")])]),v._v(" "),_("p",[v._v("你直接通过 Redis replication（异步复制） 搞个一主(master)多从(slave)来提高可用性和读吞吐量，slave 的多少取决于你的读吞吐量。")]),v._v(" "),_("p",[v._v("这样的方式有一个问题：一旦 master 宕机，slave 晋升成 master，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要"),_("strong",[v._v("人工干预")]),v._v("。")]),v._v(" "),_("p",[v._v("不过，这个问题我们可以通过 "),_("strong",[v._v("Sentinel（哨兵）")]),v._v(" 来解决。Redis Sentinel 是 Redis 官方推荐的高可用性(HA)解决方案。")]),v._v(" "),_("p",[v._v("Sentinel 是 Redis 的一种运行模式 ，它主要的作用就是对 Redis 运行节点进行"),_("strong",[v._v("监控")]),v._v("。当 master 节点出现故障的时候， Sentinel 会帮助我们实现故障转移，确保整个 Redis 系统的可用性。整个过程"),_("strong",[v._v("完全自动")]),v._v("，不需要人工介入!")]),v._v(" "),_("p",[v._v("Sentinel 也是一个 Redis 进程，只是不对外提供读写服务，通常哨兵要配置成单数。")]),v._v(" "),_("h3",{attrs:{id:"流量削峰"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#流量削峰"}},[v._v("#")]),v._v(" 流量削峰")]),v._v(" "),_("h4",{attrs:{id:"消息队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[v._v("#")]),v._v(" 消息队列")]),v._v(" "),_("p",[v._v("秒杀开始后的流量非常大，处理不了！那就先把这些请求放到消息队列中去。然后，咱后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。")]),v._v(" "),_("p",[v._v("消息队列是一种非常实用的流量削峰手段。只要是涉及到流量削峰，那必然不可缺少消息队列。")]),v._v(" "),_("h4",{attrs:{id:"回答问题-验证码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#回答问题-验证码"}},[v._v("#")]),v._v(" 回答问题/验证码")]),v._v(" "),_("p",[v._v("我们可以在用户发起秒杀请求之前让其进行答题或者输入验证码。")]),v._v(" "),_("p",[v._v("这种方式一方面可以避免用户请求过于集中，另一方面可以有效解决用户使用脚本作弊。")]),v._v(" "),_("p",[v._v("回答问题/验证码这一步建议除了对答案的正确性做校验，还需要对用户的提交时间做校验，比如提交时间过短（<1s）的话，大概就是使用脚本来处理的。")]),v._v(" "),_("h3",{attrs:{id:"限流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#限流"}},[v._v("#")]),v._v(" 限流")]),v._v(" "),_("p",[v._v("限流是从用户访问压力的角度来考虑如何应对系统故障。限流为了对服务端的接口接受请求的频率进行限制，防止服务挂掉。")]),v._v(" "),_("p",[v._v("举个例子：我们的秒杀接口一秒只能处理 10w 个请求，结果秒杀活动刚开始一下子来了 15w 个请求。这肯定不行啊！我们只能通过限流把 5w 个请求给"),_("strong",[v._v("拦截")]),v._v("住，不然系统直接就给整挂掉了！")]),v._v(" "),_("p",[v._v("限流的话可以直接用 Redis 来做（建议基于 Lua 脚本），也可以使用现成的流量控制组件比如 Sentinel 、Hystrix 、Resilience4J")]),v._v(" "),_("p",[v._v("Hystrix 是 Netflix 开源的熔断降级组件。")]),v._v(" "),_("p",[v._v("Sentinel 是阿里巴巴体提供的面向分布式服务架构的流量控制组件，经历了淘宝近10年双11（11.11）购物节的所有核心场景（比如秒杀活动）的考验。")]),v._v(" "),_("p",[v._v("Sentinel 主要以流量为切入点，提供 "),_("strong",[v._v("流量控制、熔断降级、系统自适应保护")]),v._v("等功能来保护系统的稳定性和可用性。")]),v._v(" "),_("p",[v._v("建议使用 Sentinel ，更新维护频率更高，功能更强大，并且生态也更丰富（Sentinel 提供与 Spring Cloud、Dubbo 和 gRPC 等常用框架和库的开箱即用集成， Sentinel 未来还会对更多常用框架进行适配，并且会为 Service Mesh 提供集群流量防护的能力）。")]),v._v(" "),_("p",[v._v("排队")]),v._v(" "),_("p",[v._v("你可以把排队看作是限流的一个变种。限流是直接拒绝了用户的请求，而排队则是让用户"),_("strong",[v._v("等待")]),v._v("一定的时间（类比现实世界的排队）。")]),v._v(" "),_("h3",{attrs:{id:"降级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#降级"}},[v._v("#")]),v._v(" 降级")]),v._v(" "),_("p",[v._v("降级是从系统功能优先级的角度考虑如何应对系统故障。")]),v._v(" "),_("p",[v._v("服务降级指的是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此"),_("strong",[v._v("释放服务器资源")]),v._v("以保证核心任务的正常运行。降级的核心思想就是丢车保帅，优先保证核心业务。")]),v._v(" "),_("p",[v._v("举个例子：当请求量达到一个阈值的时候，我们对系统中一些非核心的功能直接"),_("strong",[v._v("关闭")]),v._v("或者让它们"),_("strong",[v._v("功能降低")]),v._v("。这样的话，系统就有更多的资源留给秒杀功能了！")]),v._v(" "),_("h3",{attrs:{id:"熔断"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#熔断"}},[v._v("#")]),v._v(" 熔断")]),v._v(" "),_("p",[v._v("熔断和降级是两个比较容易混淆的概念，两者的含义并不相同。降级的目的在于应对系统自身的故障，而熔断的目的在于应对当前系统依赖的外部系统或者第三方系统的故障。服务熔断由链路上某个服务引起的，服务降级是从整体的负载考虑。")]),v._v(" "),_("p",[v._v("熔断：应对雪崩效应的链路自我保护机制。")]),v._v(" "),_("ul",[_("li",[v._v("微服务之间的数据交互是通过远程调用来完成的。服务A调用服务，服务B调用服务c，某一时间链路上对服务C的调用响应时间过长或者服务C不可用，随着时间的增长，对服务C的调用也越来越多，然后服务C崩溃了，但是链路调用还在，对服务B的调用也在持续增多，然后服务B崩溃，随之A也崩溃，导致"),_("strong",[v._v("雪崩效应")]),v._v("。")]),v._v(" "),_("li",[v._v("服务熔断的作用类似于我们家用的保险丝，当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，"),_("strong",[v._v("暂时停止对该服务的调用。")])])]),v._v(" "),_("p",[v._v("熔断可以防止因为秒杀交易影响到其他正常服务的提供。")]),v._v(" "),_("p",[v._v("举个例子： 秒杀功能位于服务 A 上，服务 A 上同时还有其他的一些功能比如商品管理。如果服务 A 上的商品管理接口响应非常慢的话，其他服务直接不再请求服务 A 上的商品管理这个接口，从而有效避免其他服务被拖慢甚至拖死。")]),v._v(" "),_("h2",{attrs:{id:"一致性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一致性"}},[v._v("#")]),v._v(" 一致性")]),v._v(" "),_("h3",{attrs:{id:"减库存方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#减库存方案"}},[v._v("#")]),v._v(" 减库存方案")]),v._v(" "),_("p",[v._v("常见的减库存方案有：")]),v._v(" "),_("ul",[_("li",[v._v("下单即减库存 ：只要用户下单了，即使不付款，我们就扣库存。")]),v._v(" "),_("li",[v._v("付款再减库存 ：当用户付款了之后，我们在减库存。不过， 这种情况可能会造成用户下订单成功，但是付款失败。")])]),v._v(" "),_("p",[v._v("一般情况下都是 "),_("strong",[v._v("下单减扣库存")]),v._v(" ，像现在的购物网站比如京东都是这样来做的。")]),v._v(" "),_("p",[v._v("不过，我们还会对业务逻辑做进一步优化，比如说对超过一定时间不付款的订单特殊处理，释放库存。")]),v._v(" "),_("p",[v._v("对应到代码层面，我们应该如何保证不会超卖呢？")]),v._v(" "),_("p",[v._v("我们上面也说，我们一般会提前将秒杀商品的信息放到缓存中去。我们可以通过 Redis 对库存进行"),_("strong",[v._v("原子操作")]),v._v("。")]),v._v(" "),_("p",[v._v("也可以通过 "),_("strong",[v._v("Lua 脚本")]),v._v("来减少多个命令的网络开销并保证多个命令整体的原子性。")]),v._v(" "),_("h3",{attrs:{id:"接口幂等"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口幂等"}},[v._v("#")]),v._v(" 接口幂等")]),v._v(" "),_("p",[_("strong",[v._v("什么是幂等呢?")]),v._v(" 在分布式系统中，幂等(idempotency)是对请求操作结果的一个描述，这个描述就是不论执行多少次相同的请求，产生的效果和返回的结果都和发出单个请求是一样的。")]),v._v(" "),_("p",[v._v("举个例子：假如咱们的前后端没有保证接口幂等性，我作为用户在秒杀商品的时候，我同时点击了多次秒杀商品按钮，后端处理了多次相同的订单请求，结果导致一个人秒杀了多个商品。这个肯定是不能出现的，属于非常严重的 bug 了！")]),v._v(" "),_("p",[v._v("保证分布式接口的幂等性对于数据的一致性至关重要，特别是像支付这种涉及到钱的接口。保证幂等性这个"),_("strong",[v._v("操作并不是说前端做了就可以的，后端同样要做。")])]),v._v(" "),_("p",[v._v("前端保证幂等性的话比较简单，一般通过当用户提交请求后"),_("strong",[v._v("将按钮致灰")]),v._v("来做到。后端保证幂等性就稍微麻烦一点，方法也是有很多种，比如：")]),v._v(" "),_("ol",[_("li",[v._v("同步锁；")]),v._v(" "),_("li",[v._v("分布式锁；")]),v._v(" "),_("li",[v._v("业务字段的唯一索引约束，防止重复数据产生。")])]),v._v(" "),_("p",[v._v("拿分布式锁来说，我们通过"),_("strong",[v._v("加锁")]),v._v("的方式"),_("strong",[v._v("限制用户在第一次请求未结束之前，无法进行第二次请求")]),v._v("。")]),v._v(" "),_("p",[v._v("分布式锁一般基于 Redis 来做比较多一些，这也是我比较推荐的一种方式。另外，如果使用 Redis 来实现分布式锁的话，比较推荐基于 Redisson。")]),v._v(" "),_("p",[v._v("当然了，除了 Redis 之外，像 "),_("strong",[v._v("ZooKeeper")]),v._v(" 等中间件也可以拿来做"),_("strong",[v._v("分布式锁")]),v._v("。")])])}),[],!1,null,null,null);_.default=e.exports}}]);
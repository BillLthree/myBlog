(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{419:function(v,_,a){"use strict";a.r(_);var t=a(2),r=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"oom"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#oom"}},[v._v("#")]),v._v(" OOM")]),v._v(" "),_("p",[v._v("OOM 全称 “Out Of Memory”，表示内存耗尽。当 JVM 因为没有足够的内存来为对象分配空间，并且垃圾回收器也已经没有空间可回收时，就会抛出这个错误")]),v._v(" "),_("h2",{attrs:{id:"为什么会出现-oom"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么会出现-oom"}},[v._v("#")]),v._v(" 为什么会出现 OOM？")]),v._v(" "),_("ol",[_("li",[v._v("内存分配不合理：JVM 初始化内存小，业务使用了大量内存；或者不同 JVM 区域分配内存不合理")]),v._v(" "),_("li",[v._v("代码漏洞：某一个对象被频繁申请，不用了之后却没有被释放，导致内存耗尽\n"),_("ul",[_("li",[_("strong",[v._v("内存泄漏")]),v._v("：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了。因为申请者不用了，而又不能被虚拟机分配给别人用")]),v._v(" "),_("li",[_("strong",[v._v("内存溢出")]),v._v("：申请的内存超出了 JVM 能提供的内存大小，此时称之为溢出")])])])]),v._v(" "),_("p",[v._v("内存泄漏持续存在，最后一定会溢出，两者是因果关系。")]),v._v(" "),_("h2",{attrs:{id:"常见的oom"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见的oom"}},[v._v("#")]),v._v(" 常见的OOM")]),v._v(" "),_("h3",{attrs:{id:"元空间-方法区-溢出"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#元空间-方法区-溢出"}},[v._v("#")]),v._v(" 元空间（方法区）溢出")]),v._v(" "),_("p",[v._v("报错：java.lang.OutOfMemoryError: Metadata space，元空间内存不足默认进行动态扩展")]),v._v(" "),_("h3",{attrs:{id:"虚拟机栈溢出"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机栈溢出"}},[v._v("#")]),v._v(" 虚拟机栈溢出")]),v._v(" "),_("p",[v._v("报错：java.lang.StackOverflowError")]),v._v(" "),_("p",[v._v("虚拟机栈溢出，一般是由于程序中存在 "),_("strong",[v._v("死循环或者深度递归调用")]),v._v(" 造成的。如果"),_("strong",[v._v("栈大小设置过小")]),v._v("也会出现溢出，可以通过 "),_("code",[v._v("-Xss")]),v._v(" 设置栈的大小。")]),v._v(" "),_("p",[v._v("虚拟机抛出栈溢出错误，可以在日志中定位到错误的类、方法。")]),v._v(" "),_("h3",{attrs:{id:"堆内存溢出"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆内存溢出"}},[v._v("#")]),v._v(" 堆内存溢出")]),v._v(" "),_("p",[v._v("报错：java.lang.OutOfMemoryError: Java heap space")]),v._v(" "),_("p",[_("strong",[v._v("Java 堆内存溢出")]),v._v("，溢出的原因一般由于 "),_("strong",[v._v("JVM 堆内存设置不合理")]),v._v("或者"),_("strong",[v._v("内存泄漏")]),v._v("导致")]),v._v(" "),_("p",[v._v("如果是内存泄漏，可以通过工具（MAT，Memory Analyzer堆内存分析工具）查看泄漏对象到 GC Roots 的引用链。掌握了泄漏对象的类型信息以及 GC Roots 引用链信息，就可以精准地定位出泄漏代码的位置。")]),v._v(" "),_("p",[v._v("如果不存在内存泄漏，就是内存中的对象确实都还必须存活着，那就应该检查虚拟机的堆参数（-Xmx 与 -Xms），查看是否可以将虚拟机的内存调大些。")]),v._v(" "),_("h2",{attrs:{id:"堆溢出排查思路"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆溢出排查思路"}},[v._v("#")]),v._v(" 堆溢出排查思路")]),v._v(" "),_("ol",[_("li",[_("p",[_("code",[v._v("jmap -heap")]),v._v(" 查看是否内存分布，判断内存分配是否合理")]),v._v(" "),_("p",[v._v("假设我们 Java 应用 PID 为 15162，输入命令查看 JVM 内存分布 "),_("code",[v._v("jmap -heap 15162")])])]),v._v(" "),_("li",[_("p",[_("code",[v._v("jmap -histo")]),v._v(" 查看堆中对象的统计信息（对象数量、占用内存大小），是否有明显的对象分配过多且没有释放情况")]),v._v(" "),_("p",[v._v("可以在 JVM 运行时查看最耗费资源的对象，"),_("code",[v._v("jmap -histo:live 15162 | more")])])]),v._v(" "),_("li",[_("p",[_("code",[v._v("jmap -dump")]),v._v(" 导出 JVM 当前内存快照，使用 JDK 自带的 VisualVM或者MAT等监控工具分析快照")]),v._v(" "),_("p",[v._v("Dump 文件是 Java 进程的内存镜像，其中主要包括 "),_("strong",[v._v("系统信息")]),v._v("、"),_("strong",[v._v("虚拟机属性")]),v._v("、"),_("strong",[v._v("完整的线程 Dump")]),v._v("、"),_("strong",[v._v("所有类和对象的状态")]),v._v(" 等信息")]),v._v(" "),_("p",[v._v("当程序发生内存溢出或 GC 异常情况时，怀疑 JVM 发生了 "),_("strong",[v._v("内存泄漏")]),v._v("，这时我们就可以导出 Dump 文件分析")])])])])}),[],!1,null,null,null);_.default=r.exports}}]);
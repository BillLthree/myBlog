(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{418:function(t,r,e){"use strict";e.r(r);var v=e(2),a=Object(v.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"netty"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#netty"}},[t._v("#")]),t._v(" Netty")]),t._v(" "),r("p",[t._v("Netty是一个java开源框架，现为 Github上的独立项目。Netty提供异步的、事件驱动的"),r("strong",[t._v("网络应用程序框架")]),t._v("和工具，用以快速开发"),r("strong",[t._v("高性能、高可靠性")]),t._v("的网络服务器和客户端程序。")]),t._v(" "),r("ul",[r("li",[t._v("Netty基于"),r("strong",[t._v("Java NIO")]),t._v("(同步非阻塞)，使用Netty可以极大简化TCP和UDP套接字服务器等网络编程。")]),t._v(" "),r("li",[t._v("大部分微服务框架底层涉及到"),r("strong",[t._v("网络通信")]),t._v("的部分都是基于Netty来做的，比如Spring Cloud生态系统中的网关Spring Cloud Gateway")]),t._v(" "),r("li",[t._v("应用场景：RPC框架的网络通信工具")]),t._v(" "),r("li",[t._v("Netty是"),r("strong",[t._v("异步事件驱动")]),t._v("的框架，网络IO模型采用的是Java NIO（同步非阻塞IO）。")]),t._v(" "),r("li",[t._v("Netty的NIO模型采用的是"),r("strong",[t._v("主从多线程Reactor模型")]),t._v("，是多Reactor多线程模型。")])]),t._v(" "),r("h2",{attrs:{id:"reactor模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#reactor模式"}},[t._v("#")]),t._v(" Reactor模式")]),t._v(" "),r("p",[t._v("https://zhuanlan.zhihu.com/p/368089289")]),t._v(" "),r("p",[t._v("在处理web请求时，通常有两种体系结构，分别为：thread-based architecture（基于线程）、event-driven architecture（事件驱动）")]),t._v(" "),r("p",[t._v("基于线程："),r("strong",[t._v("每当接收到一个请求，便开启一个独立的线程来处理")]),t._v("。基于线程的体系结构通常会使用多线程来处理客户端的请求，这种方式虽然是直观的，但是仅适用于并发访问量不大的场景，因为线程需要占用一定的内存资源，且操作系统在线程之间的切换也需要一定的开销，当线程数过多时显然会降低web服务器的性能。并且，当线程在处理I/O操作，在等待输入的这段时间线程处于空闲的状态，同样也会造成cpu资源的浪费。")]),t._v(" "),r("p",[t._v("基于事件驱动：事件驱动体系结构是目前比较广泛使用的一种。这种方式会定义"),r("strong",[t._v("一系列的事件处理器")]),t._v("来响应事件的发生，并且将服务端"),r("strong",[t._v("接受连接")]),t._v("与"),r("strong",[t._v("对事件的处理")]),t._v("分离。其中，事件是一种状态的改变。比如，tcp中socket的new incoming connection、ready for read、ready for write。")]),t._v(" "),r("p",[t._v("reactor设计模式**(反应器模式)"),r("strong",[t._v("是event-driven architecture的一种实现方式，"),r("strong",[t._v("处理并发服务请求")]),t._v("(客户端向服务端发出请求，请求某种服务)。每种服务在服务端可能由多个方法组成。reactor会")]),t._v("解耦**请求并分发给对应的事件处理器来处理。目前，许多流行的开源框架都用到了reactor模式，如：netty、node.js等，包括java NIO。")]),t._v(" "),r("p",[t._v("Reactor：接收客户端请求，并把IO请求分配给对应的handler处理\nAcceptor：处理客户端连接事件\nHandler：处理请求")]),t._v(" "),r("h3",{attrs:{id:"单reactor-单线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单reactor-单线程"}},[t._v("#")]),t._v(" 单Reactor 单线程")]),t._v(" "),r("p",[t._v("特点：所有的I/O操作都有同一个线程(Reactor单线程)处理。")]),t._v(" "),r("img",{attrs:{src:"https://billrepo.oss-cn-hangzhou.aliyuncs.com/doc-img/v2-e8baaf6a534a0f31e2108aab37103842_1440w.webp"}}),t._v(" "),r("p",[t._v("单线程优点是对系统资源消耗小，但不适用于大量请求，无法充分利用多核 CPU 的性能。一般不采用这种方式。")]),t._v(" "),r("p",[t._v("工作流程：")]),t._v(" "),r("ul",[r("li",[t._v("Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；")]),t._v(" "),r("li",[t._v("如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；")]),t._v(" "),r("li",[t._v("如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；")]),t._v(" "),r("li",[t._v("Handler 对象通过 read -> 业务处理 -> send 的流程来完成完整的业务流程(由Handler完成实际的业务处理)")])]),t._v(" "),r("h3",{attrs:{id:"单reactor-多线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单reactor-多线程"}},[t._v("#")]),t._v(" 单Reactor 多线程")]),t._v(" "),r("p",[t._v("特点：一个Reactor线程负责接收请求，一组线程处理 I/O 操作。")]),t._v(" "),r("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://billrepo.oss-cn-hangzhou.aliyuncs.com/doc-img/v2-5754d9ebf6b9b621a1ff89545974b6ea_r.jpg",alt:"img"}}),t._v(" "),r("p",[t._v("工作流程：")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("Reactor对象通过select"),r("strong",[t._v("监听客户端请求")]),t._v("事件，收到事件后，通过dispatch进行"),r("strong",[t._v("分发")]),t._v("。")])]),t._v(" "),r("li",[r("p",[t._v("如果建立连接请求，则Acceptor通过accept处理连接请求，然后创建一个Handler对象处理完成连接后的各种事件。")])]),t._v(" "),r("li",[r("p",[t._v("如果不是连接请求，则由reactor交给当前连接对应的handler来处理。")])]),t._v(" "),r("li",[r("p",[t._v("handler只负责"),r("strong",[t._v("响应请求")]),t._v("，"),r("strong",[t._v("不做具体的业务处理")]),t._v("，通过read读取数据后，会分发给后面的worker线程池的某个线程处理业务。")])]),t._v(" "),r("li",[r("p",[t._v("worker线程池会分配独立线程完成真正的业务，并将结果返回给handler。")])]),t._v(" "),r("li",[r("p",[t._v("handler收到响应后，通过send分发将结果返回给client。")])])]),t._v(" "),r("p",[t._v("大部分场景下多线程Reactor模式是没有问题的，但在"),r("strong",[t._v("并发连接数很多")]),t._v("(百万)的场景下，一个线程负责接收客户端请求就存在性能问题了。因为一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方。")]),t._v(" "),r("h3",{attrs:{id:"主从多线程-reactor"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主从多线程-reactor"}},[t._v("#")]),t._v(" 主从多线程 Reactor")]),t._v(" "),r("p",[t._v("也叫"),r("strong",[t._v("多Reactor 多线程")]),t._v("。特点：一组 Reactor 线程负责接收请求，一组线程处理 I/O 操作。")]),t._v(" "),r("p",[t._v("注意：Reactor主线程可对应多个Reactor子线程，即SubReactor。Netty 和 Memcache 都采用了「多 Reactor 多线程」的方案。")]),t._v(" "),r("ul",[r("li",[t._v("Reactor主线程"),r("strong",[t._v("只负责接收新连接")]),t._v("，Reactor子线程负责完成后续的业务处理(读写事件，即IO操作)。")]),t._v(" "),r("li",[r("strong",[t._v("一个subReactor对应一个线程")]),t._v("，业务逻辑由线程池里的工作线程处理。")]),t._v(" "),r("li",[t._v("主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程无须返回数据，直接就可以在子线程将处理结果发送给客户端。")])]),t._v(" "),r("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://billrepo.oss-cn-hangzhou.aliyuncs.com/doc-img/v2-ce188fec5a25fe51ea7a2151bdeff135_1440w.webp",alt:"img"}}),t._v(" "),r("p",[t._v("工作流程：")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("Reactor主线程MainReactor对象通过select监听连接事件，收到事件后，通过Acceptor处理连接事件。")])]),t._v(" "),r("li",[r("p",[t._v("当Acceptor处理连接事件后，MainReactor将连接分配给SubReactor。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("SubReactor将连接加入到连接队列进行监听")]),t._v("，并创建handler进行各种事件处理。")])]),t._v(" "),r("li",[r("p",[t._v("当有新事件发生时，SubReactor就会调用对应的handler进行各种事件处理。")])]),t._v(" "),r("li",[r("p",[t._v("handler通过read读取数据，分发给后面的"),r("strong",[t._v("work线程")]),t._v("处理。")])]),t._v(" "),r("li",[r("p",[t._v("work线程池分配独立的work线程进行业务处理，并返回结果。")])]),t._v(" "),r("li",[r("p",[t._v("handler收到响应的结果后，再"),r("strong",[t._v("通过send返回给client")]),t._v("。")])])]),t._v(" "),r("h3",{attrs:{id:"总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),r("p",[t._v("reactor相当于接待员，accepter、handler、work thread相当于服务员")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("reactor单线程，前台接待员、服务员时同一个人，全程为顾客服务。")])]),t._v(" "),r("li",[r("p",[t._v("reactor多线程，1个前台接待，多个服务员，接待员只负责接待。")])]),t._v(" "),r("li",[r("p",[t._v("主从reactor多线程，多个前台接待，多个服务员。")])])]),t._v(" "),r("p",[t._v("Reactor模式的优点：")]),t._v(" "),r("ol",[r("li",[t._v("不需要每个Client对应一个线程，提高了性能，避免多线程的切换开销。")]),t._v(" "),r("li",[t._v("扩展性好，可以方便的通过增加Reactor实例个数来充分利用CPU资源。")]),t._v(" "),r("li",[t._v("复用性好，Reactor模式本身与具体事件处理逻辑无关，具有很高的复用性。")])])])}),[],!1,null,null,null);r.default=a.exports}}]);
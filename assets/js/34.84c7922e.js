(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{433:function(t,e,v){"use strict";v.r(e);var _=v(2),s=Object(_.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"零拷贝"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#零拷贝"}},[t._v("#")]),t._v(" 零拷贝")]),t._v(" "),e("p",[t._v("在操作系统层面上的零拷贝是指避免在用户态与内核态之间来回拷贝数据，减少用户态和内核态的切换，降低开销。")]),t._v(" "),e("h2",{attrs:{id:"传统io"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#传统io"}},[t._v("#")]),t._v(" 传统IO")]),t._v(" "),e("p",[t._v("https://zhuanlan.zhihu.com/p/78869158")]),t._v(" "),e("p",[t._v("需要4次拷贝，其中"),e("strong",[t._v("两次")]),t._v(" DMA copy，"),e("strong",[t._v("两次")]),t._v(" CPU copy。")]),t._v(" "),e("p",[t._v("比如：读取文件，再用socket发送出去")]),t._v(" "),e("ol",[e("li",[t._v("第一次：将磁盘文件，读取到操作系统内核缓冲区；DMA copy")]),t._v(" "),e("li",[t._v("第二次：将内核缓冲区的数据，copy到用户态应用程序的buffer；CPU copy")]),t._v(" "),e("li",[t._v("第三步：将应用程序buffer中的数据，copy到socket网络发送缓冲区(属于操作系统内核的缓冲区)；CPU copy")]),t._v(" "),e("li",[t._v("第四次：将socket buffer的数据，copy到网卡，由"),e("strong",[t._v("网卡")]),t._v("进行网络传输。DMA copy")])]),t._v(" "),e("h2",{attrs:{id:"mmap内存映射"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mmap内存映射"}},[t._v("#")]),t._v(" mmap内存映射")]),t._v(" "),e("p",[t._v("所谓的零拷贝，就是取消用户空间与内核空间之间的数据拷贝操作，应用进程每一次的读写操作，可以通过一种方式，直接将数据写入内核或从内核中读取数据，再通过 DMA 将内核中的数据拷贝到网卡，或将网卡中的数据 copy 到内核。")]),t._v(" "),e("p",[t._v("那怎么做到零拷贝？你想一下是不是用户空间与内核空间都将数据"),e("strong",[t._v("写到一个地方")]),t._v("，就不需要拷贝了？此时你有没有想到"),e("strong",[t._v("虚拟内存")]),t._v("？")]),t._v(" "),e("p",[t._v("零拷贝有两种解决方式，分别是 mmap+write 方式和 sendfile 方式，其核心原理都是 通过虚拟内存来解决的。")]),t._v(" "),e("p",[t._v("需要3次拷贝，其中"),e("strong",[t._v("两次")]),t._v(" DMA copy，"),e("strong",[t._v("一次")]),t._v(" CPU copy。")]),t._v(" "),e("p",[t._v("从磁盘加载的数据通过DMA拷贝存储在内核缓冲区中。然后"),e("strong",[t._v("将应用程序缓冲区的页面(pages)映射到内核缓冲区")]),t._v("，这样就省略了内核缓冲区和应用程序缓冲之间的数据拷贝。")]),t._v(" "),e("h2",{attrs:{id:"sendfile"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sendfile"}},[t._v("#")]),t._v(" sendfile")]),t._v(" "),e("p",[t._v("需要3次拷贝，其中"),e("strong",[t._v("两次")]),t._v(" DMA copy，"),e("strong",[t._v("一次")]),t._v(" CPU copy。")]),t._v(" "),e("p",[t._v("当调用sendfile()时，DMA将磁盘数据复制到kernel buffer，然后将内核中的kernel buffer直接拷贝到socket buffer；一旦数据全都拷贝到socket buffer，sendfile()系统调用将会"),e("strong",[t._v("return")]),t._v("，代表数据转化的完成。socket buffer里的数据传到网卡，就能在网络传输了。")]),t._v(" "),e("p",[t._v("sendfile() 系统调用不需要将数据拷贝或者映射到应用程序地址空间中去，所以 sendfile() 只是"),e("strong",[t._v("适用于应用程序地址空间不需要对所访问数据进行处理")]),t._v("的情况。")]),t._v(" "),e("h2",{attrs:{id:"splice"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#splice"}},[t._v("#")]),t._v(" splice")]),t._v(" "),e("p",[t._v("Linux 2.6.17 支持splice(一种零拷贝技术)")]),t._v(" "),e("p",[t._v("需要2次拷贝，其中两次 DMA copy，"),e("strong",[t._v("0次")]),t._v("CPU copy。")]),t._v(" "),e("p",[t._v("将数据从磁盘读取到内核buffer后，在内核空间直接与socket buffer"),e("strong",[t._v("建立pipe管道")]),t._v("。和sendfile()不同的是，splice()不需要硬件支持。")]),t._v(" "),e("h1",{attrs:{id:"netty零拷贝"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#netty零拷贝"}},[t._v("#")]),t._v(" Netty零拷贝")]),t._v(" "),e("p",[t._v("Netty中的Zero-copy与上面我们所提到到OS层面上的Zero-copy不太一样, Netty的Zero-copy完全是在用户态的，也就是 "),e("strong",[t._v("JVM")]),t._v(" 上。它更多的是偏向于"),e("strong",[t._v("优化数据操作")]),t._v("这样的概念。")]),t._v(" "),e("p",[t._v("Netty的Zero-copy（在用户空间）体现在如下几个个方面:")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("Netty提供了"),e("strong",[t._v("CompositeByteBuf")]),t._v("类，它可以将多个ByteBuf"),e("strong",[t._v("合并")]),t._v("为一个逻辑上的ByteBuf，避免了各个ByteBuf之间的拷贝。")])]),t._v(" "),e("li",[e("p",[t._v("通过wrap操作，我们可以将byte[]数组、ByteBuf、 ByteBuffer 等"),e("strong",[t._v("包装成一个 Netty ByteBuf对象")]),t._v("，进而"),e("strong",[t._v("避免了拷贝操作")]),t._v("。")]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("例如")]),t._v("，通过 "),e("code",[t._v("Unpooled.wrappedBuffer")]),t._v("方法来将 bytes 包装成为一个"),e("strong",[t._v("Netty ByteBuf对象")]),t._v("，而在包装的过程中，是不会有复制操作的。即最后生成的 ByteBuf 对象是和 bytes 数组共用了同一个存储空间，对 bytes 的修改也会反映到 ByteBuf 对象中。")])])]),t._v(" "),e("li",[e("p",[t._v("ByteBuf 支持 "),e("strong",[t._v("slice 操作")]),t._v("，因此可以将ByteBuf"),e("strong",[t._v("分解")]),t._v("为多个"),e("strong",[t._v("共享同一个存储区域")]),t._v("的ByteBuf，避免了内存的拷贝。")])]),t._v(" "),e("li",[e("p",[t._v("通过FileRegion包装的FileChannel.tranferTo实现文件传输，可以直接将文件缓冲区的数据发送到目标Channel，避免了内存拷贝问题。")]),t._v(" "),e("blockquote",[e("p",[t._v("这与 Linux 中的 **sendfile() 方式 **在原理上是一样的。")])])])]),t._v(" "),e("p",[t._v("Netty 框架中很多内部的 ChannelHandler 实现类，都是通过 CompositeByteBuf、 slice、wrap 操作来处理 TCP 传输中的"),e("strong",[t._v("拆包与粘包")]),t._v("问题的。")]),t._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("Netty的零拷贝与操作系统的零拷贝是有些区别的，Netty 的零拷贝偏向于用户空间中\n对数据操作的优化，这对处理 TCP 传输中的拆包粘包问题有着重要的意义，对应用程序处理请求数据与返回数据也有重要的意义。")]),t._v(" "),e("p",[t._v("在 RPC 框架的开发与使用过程中，我们要深入了解网络通信相关的原理知识，尽量做到零拷贝，如使用 Netty 框架；我们要"),e("strong",[t._v("合理使用 ByteBuf 子类")]),t._v("，做到完全零拷贝，提升 RPC框架的整体性能。")])])}),[],!1,null,null,null);e.default=s.exports}}]);